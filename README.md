# Ball and Plate Balancing System
This project is a real-time, closed-loop control system that uses computer vision to balance a ball on a 2-axis tilting plate. The system can also guide the ball to follow dynamic paths, such as a circle or an 8-shape, all controlled via a custom Python GUI.

Initial simulations for the control logic were performed in MATLAB & Simulink (see MATLAB_Simulink folder). The physical model was constructed using custom 3D-printed components.

üé• Demonstration
The video below shows the ball successfully tracking a circular setpoint (red dot) generated by the GUI.

(Pro Tip: Convert your circle_video.mp4 to a demo.gif to embed it here. You can't embed videos directly, but a GIF will auto-play.)

![System Demo](demo.gif)

‚öôÔ∏è Technical Workflow
The system operates in a continuous "see-think-act" loop:

1. Plate Detection (Region of Interest)
To focus processing power and eliminate noise, the system first isolates the plate:

Edge Detection: A first pass is done to identify rectangular shapes in the camera feed.

Color Filtering: The selection is refined by searching for a specific yellow color, locking onto the plate.

Cropping: The video feed is then trimmed to the plate's dimensions (with a 2-pixel offset), creating a precise Region of Interest (ROI).

2. Ball Detection (3-Filter Pipeline)
A robust, 3-stage filter is used to accurately detect the ball within the ROI:

Hough Circle Transform: Detects all circular objects.

Color Filter: Isolates the objects that match the ball's specific color.

Shape & Size Validation: A final filter ensures the object is perfectly round and within the expected size range, rejecting any "absurd" circles or visual noise.

3. PID Control Loop
Error Calculation: Once the ball's (x,y) position is found, the system calculates the error vector (distance) between the ball and the target setpoint (the blue dot).

PID Controller: This error is fed into a PID controller. The controller's output (the corrective tilt angles) is calculated based on the gains (Kpx, Kpy, Kix, Kiy, Kdx, Kdy) set in the GUI.

Serial Communication: The calculated X and Y tilt angles are sent to the Arduino via serial communication at a fixed baud rate.

4. Hardware Actuation
The Arduino, running the final_arduino.py logic, receives the target angles.

It translates these angles into the precise angular positions required for the two servo motors.

The servos tilt the plate, which moves the ball, thus closing the loop.

üöÄ Key Features
Real-time PID Control: All P, I, and D gains for both X and Y axes can be tuned live via the GUI for optimal performance.

Dynamic Path Following: Includes modes for "Circle Movement" and "8-Shape Movement," where the setpoint moves and the ball dynamically follows.

Robust 2-Stage Plate Detection: Uses both shape and color to lock onto the plate and create a processing-efficient ROI.

High-Accuracy 3-Filter Ball Tracking: Drastically reduces false positives by filtering for shape, color, and size.

3D-Printed Hardware: The majority of the mechanical components are 3D-printed.

Initial Simulation: Includes MATLAB/Simulink files for reference, showing the initial design and testing of the control theory.

üìÇ File Structure
üõ†Ô∏è Hardware & Software
Required Hardware
Arduino (or compatible microcontroller)

2x Servo Motors

USB Webcam

3D-Printed components

A yellow-colored plate

A distinctly colored ball

Software Setup
Python Environment: This project requires Python 3. You can install the necessary libraries using pip:

Arduino Setup:

Upload the code from final_arduino.py to your Arduino board.

Ensure the baud rate in the script matches the one set in interface.py.

‚ñ∂Ô∏è How to Run
Assemble the hardware and connect the Arduino to your computer.

Position the webcam directly above the plate for a top-down view.

Run the main Python application:

The GUI will open, and the camera feed will start.

Use the GUI to tune the PID gains for stable balancing.

Enable the "Circle Movement" or "8-Shape Movement" modes to test dynamic tracking.
